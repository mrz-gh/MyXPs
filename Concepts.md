# Concepts
electromigration

Solid-state is a common descriptor used to refer to electronic components, devices and systems based entirely on **semiconductor** materials


**power network design** is the analysis and design of **on-chip** [conductor](https://en.wikipedia.org/wiki/Electrical_conductor "Electrical conductor") networks that distribute [electrical power](https://en.wikipedia.org/wiki/Electric_power "Electric power") on a chip.


Compute-in-Mem.
Spiking Neural Networks
Neuromorphic Computing


The computing world is witnessing a proverbial Cambrian explosion of emerging paradigms propelled by applications, such as artificial intelligence, big data, and cybersecurity. The recent advances in technology to store digital data inside a deoxyribonucleic acid (DNA) strand, manipulate quantum bits (qubits), perform logical operations with photons, and perform computations inside memory systems are ushering in the era of emerging paradigms of DNA computing, quantum computing, optical computing, and in-memory computing. In an orthogonal direction, research on interconnect design using advanced electro-optic, wireless, and microfluidic technologies has shown promising solutions to the architectural limitations of traditional von-Neumann computers. In this article, experts present their comments on the role of interconnects in the emerging computing paradigms, and discuss the potential use of chiplet …


LDPC encoding and decoding

Federated Learning


Stochastic computing (SC) uses streams of pseudo-random bits to perform low-cost and error-tolerant numerical processing for applications like neural networks and digital filtering.





- .vscode

- .idea

DNS Filter

Warp

set_app_var vs set

Tcl

CLI interface:

-	.cmd

-	.bat

-	.sh

LCD classes:

-	IPS

-	TFT

-	LDPC

#if vs #ifndif

#define vs const

ANNS

HDC

Buffer - Cache - RAM

ADSL

Attention - Query

.do file

Data Analysis Methods

Black holes

POSIX vs OpenMP

CentOS

Docker

What type of frying pan is resilient to metal spoons?

Keras.callbacks

Optimizer vs Loss Func

Attention mask

Require_grad

Pytorch vs Tensorflow

Prune

Topk

Fork

Dependabot

Standalone

Error-prone

AXI stream Bus

Bus protocols

Saint Valentine

Morph

- Rendering
	- Ray Tracing
	- Scanline Rendering

Chiplet
vs 
Monolithic Chips

Types of research

VLSI researcher

Clock gating

SLAM

Unmanned Robots

Adversarial 

Closed Source, Proprietary, commercial


Tex and Latex

Chrome , Chromium

Mozilla FireFox



Newlib vs Linux



Pot Materials:

-	Iron

-	Steel

-	Stainless steel

-	Cast iron

-	Teflon




superclass vs subclass




Security Deposit vs Mortgage vs Rent

Down payments vs Closing costs


self-check mechanisms

Makefile , build process



Automation, Modeling, Verification


GitLab


There are several alternatives to the Universal Verification Methodology (UVM) for hardware verification. These alternatives offer different approaches and frameworks for verifying hardware designs. Here are a few notable alternatives:

1. SystemVerilog Assertions (SVA): SVA is a formal verification language integrated into SystemVerilog. It allows you to specify properties and assertions directly in the hardware description language, enabling formal verification techniques to be applied. SVA is often used in combination with other verification methodologies.

2. Property Specification Language (PSL): PSL is another formal verification language that allows you to express properties and assertions for hardware verification. It provides a set of temporal and dataflow operators to describe complex behaviors and properties of a design. PSL is often used with formal verification tools.

3. Assertion-Based Verification (ABV): ABV is a verification methodology that focuses on using assertions and properties to verify the behavior and correctness of a design. It involves specifying assertions and checking them against simulation or formal verification environments. ABV can be used in conjunction with other verification methodologies.

4. Transaction-Level Modeling (TLM): TLM is a high-level modeling approach that focuses on modeling the behavior of a design at a transaction level rather than at the signal level. TLM allows for faster simulation and easier testbench development. TLM can be combined with other methodologies like UVM or used independently.

5. Formal Verification: Formal verification is a methodology that uses mathematical techniques to prove the correctness of a design. It involves exhaustively analyzing the design against specified properties and checking for violations or proving their absence. Formal verification can be used alongside other methodologies or as a standalone verification approach.

6. Emulation: Emulation involves using hardware emulators to verify the functionality and performance of a design. Emulation platforms provide high-speed simulation and debugging capabilities, allowing for the execution of large and complex designs. Emulation can be used in conjunction with other methodologies like UVM or standalone.

These are just a few alternatives to UVM in hardware verification. The choice of methodology depends on the specific requirements of the project, the complexity of the design, and the available resources and expertise. Many verification projects combine multiple methodologies to achieve comprehensive verification coverage.





Markup Language vs WYSIWYG = 
TeX vs MS Word
.rst vs .md
xml, html


RISC-V compliance refers to the adherence and compatibility of a computer processor or system with the RISC-V instruction set architecture (ISA).


degree conferral

Director vs Coordinator

Data Science

.ansi vs .txt


https://en.wikipedia.org/wiki/Comparison_of_office_suites



Build vs compile vs parser vs execution



YAML (YAML Ain't Markup Language) is a human-readable data serialization format. It is often used as an alternative to JSON or XML for configuration files, data serialization, and interchanging data between different systems.

sandbox

An **industry solution** refers to a comprehensive set of software, tools, and services specifically designed and tailored to meet the needs of a particular industry or sector.

A **sanity test**, also known as a smoke test or build verification test, is a basic level of testing performed on a software application or system to quickly determine if it is functioning correctly after a new build or release.


ISO/IEC

QT-based UI vs MFC-based UI


CRLF vs LF

'with' statement:
	- unallocate resource if an exception occurs
	- '__enter__()'


weak vs strong typing = type checking: runtime vs compile time 



uvm subscriber


identifier vs text 